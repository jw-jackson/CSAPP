#  2 信息的表示和处理

## 2.1 信息存储



### 2.1.9 C 语言中的移位运算

* 左移运算很常规，右端补 0
* 右移运算很微妙，一般而言机器支持两种形式的右移：**逻辑右移**和**算术右移**。其区别就是高位的补充方式不同。

C 语言标准没有明确定义对于有符号数应该使用哪种。unfortunately，我们假设哪种都会出现可移植性问题。但是几乎所有编译器/机器组合都对有符号数使用的是算术右移，且程序员也都假设的是这种右移。



**移位 k 位，这里 k 很大**

对于一个待移动的 w 位的值，移位指令只考虑位移量 k 的低 log2w 位，其等同于 k mod w。

这里引发了一个思考，取余运算有点类似于掩码。





## 2.2 整数表示

整数有两种编码方式：

* 一种只能表示非负数
* 另一种只能表示负数、零和正数



### 2.2.1 整型数据类型

C 语言支持多种整型类型——表示有限范围的整数。

每种类型都能用关键字`char` `shrot` `long` 指定大小，还能用 `unsigned`指定范围。

为这些类型分配的字节数根据程序编译为 32 位还是 64 位而有所不同，但这其中唯一一个与机器相关的指示符是 `long`。其在 64 位程序下位 8 字节，再 32 位程序下为 4 字节。





### 2.2.2 无符号数的编码

对于 w 位的无符号整数类型，将二进制到无符号数进行映射，其范围为`0 ~ 2^w-1`。

将 w 位的编码的位向量依次映射为`2^(w-1) ... 2^0`

无符号数的编码具有唯一性，因为映射函数`B2U`是一个双射。



### 2.2.3 补码编码

补码`two's complement`的出现是为了解决有符号数的计算机表示，其能直接参与运算的特性使其成为了有符号数的最常见表示方式。

其将 w 位的编码依次映射为`-2^(w-1) 2^(w-2) ... 2^0`

可见其取值范围为`-2^w ~ 2^(w-1)-1`

出现**不对称性**的原因：一半的位模式（符号位设置为1）表示负数，一半的位模式（符号位设置为0）表示非负数，这其中包括0

C 库中的文件 `limits.h` 中定义了一组常量，来限定编译器运行的这台机器的不同的整型数据类型的取值范围



### 2.2.4 有符号数和无符号数之间的转换

对于大多数的 C 语言实现，处理同样字长的有符号数和无符号数之间的相互转换的一般规则是：**数值可能会变，但是位模式不变 **



```
对于 w 位的补码转化为无符号数：
x >= 0, T2U(x) = x
x < 0,  T2U(x) = 2^w + x
```



### 2.2.5 C 语言中的有符号数和无符号数

通常大多数数字都默认是有符号的。例如声明一个 1234 这样的常量时，其被认为是有符号的，**要创建一个无符号常量，必须加上后缀‘u’，如 1234u**。

当执行一个运算时，如果它的一个运算数是有符号，另一个是无符号的，那么**C 语言会隐式地将有符号参数强制转化为无符号数，并假设这两个数是非负的，来执行这个运算。**这种方式对标准的算术运算来说并无太大差异，（这里的无大差异没有理解），但是对于`< > ==`这样的关系运算符来说，会产生非直观的结果。

```C++
#include <iostream>
int main(){
    int a = 0;
    unsigned int b = -1;
    std::cout << (a + b) << std::endl; //4294967295
    std::cout << (b < a) << std::endl; //0
    return 0;
}
```



### 2.5.6 拓展一个数字的位表示

在不同字长的整数之间转换的运算是常见的，从一个较小的数据类型转化为一个较大的数据类型是可行的。

**无符号数的零拓展**：要将一个无符号数转化为更大的数据类型，我们重要简单地在表示的开头添加0，这种运算被称为**零拓展 zero extension**。

**补码数的符号拓展**：要将一个补码数字转化为更大的数据类型，可以执行一个**符号拓展 sign extension**，在表示中添加最高有效位的值。
